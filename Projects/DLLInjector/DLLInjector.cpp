/* Basic DLL Injector, recreated from a similar script provided to me from a friend. */
#include <iostream>
#include <string>
#include <Windows.h>
#include <psapi.h>
#include <processthreadsapi.h>
#include <TlHelp32.h>
#include <cstdlib>

// Injecting the DLL at this location
const char* DLL_PATH = "C:\\LSMODULE.dll";

// make PID more automated
void get_pids() {

}


void* get_module_baseaddr(HANDLE proc, std::string const& dllname)
{
    // lpcbNeeded - The number of bytes required to store all module handles in the lphModule array.
    DWORD bytes_needed = 0;
    DWORD junk = 0;
    // can be LIST_MODULES_(32/64/ALL/DEFAULT)BIT 
    // even though the return is a BOOL it also calculates size of all the modules and places it in &bytes_needed 
    // hence the need to run EnumProcessModulesEx twice
    BOOL rv = EnumProcessModulesEx(proc, NULL, 0, &bytes_needed, LIST_MODULES_ALL);
    // I think this is meant to clear the modules the modules array by using calloc first you can run malloc and memset in one func
    HMODULE* modules = (HMODULE*)calloc(bytes_needed, 1); // malloc + memset to 0 in one func
    EnumProcessModulesEx(proc, modules, bytes_needed, &junk, LIST_MODULES_ALL);
    std::cout << "number of modules is: " << bytes_needed / sizeof(HMODULE) << std::endl;


    /*
      An HMODULE is just the same in 64 bit as it is in 32 bit.
      It is the base address of the loaded module.
      So there is no reason why a valid HMODULE would have to have non-zero low order bits.
      ... I think this is to get the size in bytes... maybe?
    */
    for (int i = 0; i < bytes_needed / sizeof(HMODULE); i++) {
        // Maximum Path Length Limitation - 
        // https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=cmd
        // cname for holding path name
        char cname[MAX_PATH] = { 0 };
        // Retrieves the fully qualified path for the file containing the specified module.
        // man... there is really a WinAPI for everything huh.
        // sets the cname as a return as well.
        // Get the Module file names one i iteration at a time
        GetModuleFileNameExA(proc, modules[i], cname, MAX_PATH);
        // convert cname to std::string var named cppname
        std::string cppname(cname);
        // npos is a static member constant value with the greatest possible value for an element of type size_t.
        // so basically if the DLL name passed into the function is found in the full path 
        // return that full path contained in the current i iteration of modules
        if (cppname.find(dllname) != std::string::npos)
            return (void*)modules[i];
        std::cout << cppname << std::endl;
    }

    return 0;
}

// quick and dirty injector
void inject(HANDLE target_proc, std::string const& dll_path)
{
    // Allocate spaces for our injected DLL to live
    // https://stackoverflow.com/questions/22750112/dll-injection-with-createremotethread
    // https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex
    LPVOID path_addr = VirtualAllocEx(target_proc, 0, strlen(DLL_PATH) + 1, MEM_COMMIT, PAGE_READWRITE);
    std::cout << "Allocated dll path space at address: " << std::hex << path_addr << std::endl;

    // Write the path into its new home
    SIZE_T bytes_written = 0;
    // Writes data to an area of memory in a specified process. 
    // The entire area to be written to must be accessible or the operation fails.
    WriteProcessMemory(target_proc, path_addr, DLL_PATH, strlen(DLL_PATH) + 1, &bytes_written);
    std::cout << "Wrote path to allocated space..." << std::endl;


    // get target_base address using our get_module_baseaddr and the starting point of Kernel32.dll 
    size_t target_base = (size_t)get_module_baseaddr(target_proc, "KERNEL32.DLL");
    // load Kernel32.dll
    size_t local_base = (size_t)GetModuleHandleA("KERNEL32.dll");
    // using the local base address get the procaddress
    size_t addr_loadlib = (size_t)GetProcAddress((HMODULE)local_base, "LoadLibraryA");
    // calculate the offset by subtracting the address of the loaded library and the base address
    size_t delta = addr_loadlib - local_base;
    // print the addys and offset
    std::cout << "Local Kernel32.dll addr:" << std::hex << local_base << std::endl;
    std::cout << "Local loadlibrarya addr:" << std::hex << addr_loadlib << std::endl;
    std::cout << "Offset: " << std::hex << delta << std::endl;
    // derive the remote_addr by adding the offset and the target base
    size_t remote_addr = target_base + delta;
    std::cout << "remote LoadLibraryA at: " << std::hex << remote_addr << std::endl;

    // Creates a thread that runs in the virtual address space of another process.
    // injecting our LPVOID path_addr into the new thread starting at remote_addr.
    // so basically this is the DLL load at this point.
    CreateRemoteThread(target_proc, NULL, 0, (LPTHREAD_START_ROUTINE)remote_addr, path_addr, 0, NULL);

}

int main()
{
    std::cout << "Feed me a PID\n";
    std::string input;
    std::getline(std::cin, input);
    int pid = std::stoi(input);

    // Get a handle on the target process by pid
    HANDLE target_proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    std::cout << "Target pid: " << pid << std::endl;
    std::cout << "Handle: " << std::hex << target_proc << std::endl;

    inject(target_proc, DLL_PATH);
}